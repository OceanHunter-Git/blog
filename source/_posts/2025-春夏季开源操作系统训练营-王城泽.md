---
title: 2025 春夏季开源操作系统训练营-王城泽
date: 2025-03-24 20:13:13
tags:
    - author:OceanHunter-Git
---

# 03.24

做了rustlings的练习中的枚举，字符串，模块，哈希表的部分。

字符串又学了一些方法，`trim`可以去除字符串两端的空白字符，生成的是一个新的&str

哈希表的`entry`和`or_insert`的配合挺好的，可以让entry保证输出一个指针。

模块的内容还不是很懂。

# 03.25

今天没花太多时间在rust上，就看了rust course的方法和泛型的一部分。

# 03.26

看书的错误处理部分

调试时用`unwrap`和`expect`直接崩溃方便快速搭建代码。

`?`太强了，遇到`Result`如果是错误直接返回，还能自动提升类型，遇到`option`如果是空值则直接返回空置，还能链式调用。

`map`可以对`option`中的值进行简单的改变，`and_then`可以创建于一个新的`option`类型对象。

之前老是看到特征，今天终于学到了。

特征约束强大，特征约束的语法糖便利。

继续做rustlings，今天做了option,error，generics和traits。

# 03.28

泛型和特征对象差别还挺大，泛型是在编译过程中编译器为每个用到的具体类型生成了一份代码。那也就是说其实调用的函数的输入值返回值的类型是确定的，所以也就不能返回具有相同特征的两个不同类型对象。

生命周期标注是为了让告知编译器被引用的生命周期大于引用，生命周期如果标的过大，编译器虽然通过但实际运行就要出错了。

rust的迭代器太强大了，collect可以根据指定类型收集数据。

今天完成了test,lifetime和iterator。

# 03.29

主要学了智能指针，感觉Rc和c++的shared_ptr差不多都有一个引用计数。查了一下c++的shared_ptr是线程安全的，rust中与之对应的应该是原子化的Arc。线程安全好像又是一块很大的内容。

cell实现了存在多个可变引用的效果，但实际上并不是多个可变引用，只是借助了cell的方法修改了内部数据，实际上还是不可变引用，而get实际上是获得了数据的副本，这也就是为什么cell要求具有copy特征。

# 03.30

今天学习了多线程部分，rustlings中的线程部分是做出了，但是还是不是很理解。一个使用Arc和mutex实现，一个是用消息传递实现。

# 03.31

今天学习了宏，类型转换。感觉理解都不是很透彻，都只能做一下题目，熟悉一下语法结构。接下来要做十道算法题了。

# 04.01

做了算法中的单向链表，排序，bfs，dfs，用栈检验括号，用队列实现栈。

# 04.02

终于完成rustlings了，感觉有多层包裹的时候还是搞不太清是copy还是clone还是转移。

# 04.03

学习了rCore指导书的第一章。感觉有好多看不懂啊，有很多语句要在第二章讲。

# 04.04

原来的实验指导书看不懂，感觉那个知道好像默认我什么都知道了，现在去看rCore-tutorial-Book-V3了，这个讲的很详细。了解了可执行文件是怎么形成的，cpu内部的函数调用是怎么发生的。

# 04.05

理解分支ch1的代码。大概对源文件一步步变成可执行文件有了了解。

# 04.06

批处理系统为了保证内核的安全，将特权级分为内核态和用户态，当应用程序想要做一些可能危害到计算机系统的内核态特权级指令时需要向内核发出请求，转换执行环境。

# 04.07

开始看批处理系统的具体实现。

# 04.09

实现批处理系统的关键在于对trap的处理，由于在处理trap时会修改cpu中寄存器的数据，而在处理完trap后还要继续运行应用程序，需要把这些存在寄存器的数据全部保存在内核栈中，在处理完trap后再将这些数据加载到寄存器中。

# 04.11

认识了更先进的操作系统，多道任务和协作式调度系统。通过把多个应用程序都载入内存，CPU的速度远快于I/O的速度，在发送I/O请求后到得到数据中间这段时间CPU的计算性能都是浪费的。应用程序在发出I/O请求后主动yield，交出CPU的使用权。这样的设计提高了CPU的利用率，但是通过应用程序主动交出使用权的方式，让切换任务的时机十分不确定。

# 04.12

为了解决之前协作式调度交还控制权时间不确定的问题，抢占式调度出现了，通过时钟中断来控制每次应用程序运行的时间。时钟中断也是一种trap，在traphandle中新增一个处理时钟中断的分支，保存当前任务的上下文，回复下一个任务的上下文。

做ch3的练习的时候调式的时候发现程序卡住了，在user程序中添加输出发现get_time的返回值一直都是0，注释掉新增的有关trace的代码后发现get_time正常，发现是用于存储syscall_counts的数组大小过大，导致内存分配可能产生了一些问题，改小后就解决了。

# 04.13

今天完成了ch3的练习。

# 04.14

今天花费了一点时间配置了一下wsl的环境，昨天通过git config设置的代理今天也行不通了。rCore刚开始看第四章，这章需要实现动态分配内存和通过页表实现虚实内存映射。动态内存是为了提高内存的利用率，第三章中的内存使用空间在其运行前已经限定死了，无法再某些应用完成后将这部分内存再利用。页表是为了提高系统的安全性和灵活性，原来的应用程序拥有对所有物理内存读写的权力，可能会导致读写其他应用的数据甚至修改内核。虚拟地址也可以让应用开发更灵活，不需要在意物理内存的布局，在应用角度来看就是一块连续的内存。

# 04.15

看完SV39页表的实现机制。

# 04.16

看完实现地址空间的抽象。

# 04.18

看完第四章有关跳板的内容，用来保证切换地址空间时的连续性。

# 04.19

开始做第四章的实验，今天完成了在有地址空间的情况下重新实现sys_trace。由于map和unmap的部分还没有完成，就先单独测试了一下sys_trace的部分，发现对于一些特殊情况的测试用例有问题。对于一般的非法地址通过判断是否在页表中来解决。但是对于isize::MAX这个例子有问题，他是能在页表中寻找的。分析了一下应该是由于SV39分级页表实际上的VAddress只有39位，那么对于在取VPN时取到的实际上是0，而VPN为0的页确实在页表中的。所以我直接直接加了一个判断条件，让VPN超过39位的直接返回-1。不知道是不是正确的解决方法。

# 04.21

实现了syscall中的mmap函数的一部分，在mmap的测试用例中出现了对不可写数据进行写入，修复了一下sys_trace的写入和读取，判断了页表项中的标志位再进行输入输出。

# 04.23

基本完成了mmap函数的编写，除了对于已映射页重叠的判断在特殊情况下还有点问题，然后准备开始munmap函数的编写。

# 04.24

完成munmap函数的书写，mmap之前的问题是因为新的逻辑段的开始VPN与已存在的某个逻辑段的结尾VPN相同，但实际上结尾VPN是向上取整获取的，可以与新逻辑段的开始VPN相同，修改逻辑后通过了第四章的代码编写部分。

# 04.25

完成lab2的report。开始看第五章，了解进程的概念和相关重要的系统调用。

# 04.26

学习进程管理的设计实现，完成对sys_get_time还有sys_mmap还有sys_munmap的移植。

# 04.27

写sys_spawn,遇到了一些问题，和fork部分应该没关系，应该是exec部分的问题。

# 04.28

完成了sys_spawn，写的应该没问题,在测试中通过了,调试中需要改文件名。